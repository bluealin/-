https://blog.csdn.net/HHcoco/article/details/53117525
Collection（单列集合）

1.List（有序（存储与取出的顺序一致），可重复）

1.1. ArrayList

底层数组实现，查询快，增删慢，线程不安全，效率高。

1.2.Vector

底层数据结构是数组实现，查询快，增删慢，线程安全，效率低。

1.3. LinkedList

底层数据结构是链表实现，查询慢，增删快，线程不安全，效率高
------------------------------
2.Set（无序（存储与取出的顺序不一致），唯一）

2.1. HashSet

底层数据结构由哈希表（实际上是一个 HashMap 实例）实现，它不保证 set 的迭代顺序。允许使用 null 元素，

                                依赖 hashCode()和equals()方法来区分存入的元素是否相同，来保证存储元素唯一性。

这两个方法（可自动生成）的执行顺序：

首先判断元素的hashCode()值是否相同

否：直接存储到集合

是：继续执行equals(),看其返回值

true：说明元素相同，就不存储

false：说明元素不同，就存储到集合

2.1.1. LinkedHashSet

底层数据结构由哈希表和链表组成。

哈希表保证元素的唯一性，链表保证元素有序（存储和取出一致）。

2.2. TreeSet

底层数据结构是红黑树。（是一种自平衡的二叉树结构）

元素的唯一性：

依靠元素比较的返回值是否为0来决定

元素的有序性：

1.自然排序（元素具备比较性）

无参构造（new TreeSet<T>()）使用的是自然排序，让元素所属的类实现自然排序接口，

                                                底层用CompareTo()方法（Comparable接口）来做数据校验

2.比较器排序（集合具备比较性）

构造方法（new TreeSet<T>(Comparator comparator)）接收一个比较器接口（其实是该接口的子类对象），

底层使用Compare()方法来做数据校验

---------------------
二、Map（双列集合）

A:Map集合的数据结构仅仅针对键有效，和值无关。

B:存储的是键值对元素，键是唯一的，值可重复

1. HashMap

底层数据结构由哈希表实现，它不保证 set 的迭代顺序。允许使用 null 元素，

                        依赖hashCode()和equals()方法来区分存入的元素是否相同，来保证存储元素唯一性。

这两个方法（可自动生成）的执行顺序：

首先判断元素的hashCode()值是否相同

否：直接存储到集合

是：继续执行equals(),看其返回值

true：说明元素相同，就不存储

false：说明元素不同，就存储到集合

1.1. LInkedHashMap

底层数据结构由哈希表和链表组成。

哈希表保证元素的唯一性，链表保证元素有序（存储和取出一致）。

2. Hashtable

Hashtable与HashMap的区别

Hashtable：线程安全，效率低，不允许null键和null值

HashMap：线程不安全，效率高，允许null键和null值

3. TreeMap

底层数据结构是红黑树。（是一种自平衡的二叉树结构）

元素的唯一性：

依靠元素比较的返回值是否为0来决定

元素的有序性：

1.自然排序（元素具备比较性）

无参构造（new TreeSet<T>()）使用的是自然排序，让元素所属的类实现自然排序接口，

                                        底层用CompareTo()方法（Comparable接口）来做数据校验

2.比较器排序（集合具备比较性）

构造方法（new TreeSet<T>(Comparator comparator)）接收一个比较器接口（其实是该接口的子类对象），

底层使用Compare()方法来做数据校验

---------------
d.多线程环境下，通常也不是用HashTable，因为效率低。HashMap配合Collections工具类使用实现线程安全。
同时还有ConcurrentHashMap可以选择，该类的线程安全是通过Lock的方式实现的，所以效率高于Hashtable。
----不同点
数组，链表，哈希表。各有优劣，顺便提一下，数组连续内存空间，查找速度快，增删慢；链表充分利用了内存，存储空间是不连续的，

首尾存储上下一个节点的信息，所以寻址麻烦，查找速度慢，但是增删快；哈希表呢，综合了它们两个的有点，一个哈希表，

由数组和链表组成。假设一条链表有1000个节点，现在查找最后一个节点，就得从第一个遍历到最后一个；如果用哈希表，将这条链表分为10组，
用一个容量为10数组来存储这10组链表的头结点（a[0] = 0 , a[1] = 100 , a[2] = 200 …）。这样寻址就快了。

HashMap实现原理就是上述原理了，当然其具体实现还有很多其他的东西。Hashtable同理，只不过做了同步处理。


好了，到了总结的时候了，其实你会发现集合类虽然看起来多，但是都是很有规律的。ArrayList,LinkedList一个无序，一个有序；
HashSet,TreeSet一个无序，一个有序；HashMap,LinkedHasmMap,一个无序，一个有序；Vector和HashTable，Stack是线程安全的，
但是效率低；线程不安全的类都可以配合Collections得到线程安全的类。

Hash碰撞，不同的key根据hash算法算出的值可能一样，如果一样就是所谓的碰撞。
